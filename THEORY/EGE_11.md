## О задании

Задание 11 ЕГЭ по информатике нацелено на проверку умений учащихся подсчитывать **информационный объём сообщения**. Это задание, в целом, очень похоже на рассмотренное ранее [задание 7](https://future-step.ru/tutor/task-7/), где требовалось подсчитать вес изображения, звукового или видеофайла.

Но в случае с 11 заданиями, мы будем работать только с **текстовой** информацией. Это во многом упрощает решение задания 11, однако, в нём присутствует ряд **моментов**, на которые стоит обратить внимание, чтобы не случайно не допустить ошибку в ответе.

О всех тонкостях и не самых очевидных моментах мы и поговорим в этой статье. Но для начала, давайте узнаем, как в компьютере хранится информация и как правильно определять её объем.

## Хранение информации в компьютере

В современном мире информационные технологии стали неотъемлемой частью нашей жизни. Компьютеры, смартфоны и другие устройства стали нашими верными помощниками в работе, учёбе и развлечениях. Но как именно хранится информация в этих устройствах?

Любой современный компьютер — это **цифровое** устройство. В прошлой [статье](https://future-step.ru/tutor/task-7/), посвящённой заданию 7 ЕГЭ по информатике, мы уже выяснили, чем отличаются аналоговые сигналы, от цифровых. Аналогично дело обстоит и с устройствами. Цифровые устройства могут работать только с **цифровыми** сигналами. А значит, что любая информация — текстовая, звуковая, графическая — может храниться только в виде определённого набора **цифр**. Но каких цифр?

Таких цифр, с помощью которых можно хранить любую информацию, всего две — **0** и **1**. По правде говоря, если немного углубиться в устройство процессора и любой цифровой электроники, то это даже не цифры. Это лишь **логические значения**, которые указывают, что напряжение электрического сигнала в момент измерение преодолело заданный порог.

![Задание 11](https://future-step.ru/wp-content/uploads/2024/12/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-11-1@2x.svg "Задание 11 – 1@2x")

Аналогично, можно вместо 0 и 1 использовать слова («Да» и «Нет», «Истина» и «Ложь», «Высокий» и «Низкий») или попросту включение и выключение лампочки. Суть будет одна и та же — мы просто указываем на одно из двух возможных **состояний** системы. Но именно использование цифр 0 и 1 открывает нам дорогу к возможностям **кодирования** информации.

Представим такую ситуацию: у нас есть пятибалльная шкала оценивания работы учащихся. И все оценки необходимо как-то хранить в компьютере — в цифровом виде. При этом, мы не можем просто так записать в память компьютера цифру 5. Наши микросхемы памяти просто не поймут, что это такое. У них ведь есть только **2 значения**: нет напряжения (**логический 0**) и напряжение выше порогового (**логическая 1**).

Здесь и вступает в игру кодирование. Каждый символ нашей шкалы оценивания мы можем закодировать несколькими значениями из **двух**: нуля и единицы.

Например, для значения «1» все просто — используем одну единицу. Со значением «2» уже посложнее. Можем записать её как одну единицу и один ноль, следующие друг за другом — «10». Тогда числу «3» у нас будет соответствовать значение «11», 4 — «100», а «5» — «101». Да, мы с вами только что заново придумали **двоичную** систему счисления.

Но в этой статье мы поговорим немного о другом. Вот есть у нас оценки, закодировали мы их. А **сколько памяти** выделять под 1 оценку? А под 10?

Минимальной базовой единицей измерения информации в компьютерных системах является **бит**. Каждый бит может принимать одно из двух значений: 0 или 1. Соответсвтенно, если мы хотим вычислить объём памяти под одну оценку, нам необходимо понять, сколько бит требуется, чтобы **максимальное** закодировать значение этой оценки.

Если значение «1» мы можем закодировать одним битом, «2» и «3» — двумя, а «4» и «5» (максимальное) — тремя, то это означает, что под **любую** оценку нам необходимо выделять память под **3 бита**. Иначе у нас просто может **не поместиться** какая-либо оценка. Например значения «4» и «5» не поместятся, если у нас будет выделено под оценку всего 2 бита.

Можно представить выделяемую под оценки память как некие **ячейки**, в которых мы храним значение каждого числа. Если ячеек будет меньше, то и число не поместится. А если нам требуется всего 1 ячейка (как для значения «1»), то оставшиеся ячейки слева заполним **незначащими нулями.**

![Задание 11](https://future-step.ru/wp-content/uploads/2024/12/%D0%97%D0%B0%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-11-2@2x.svg "Задание 11 – 2@2x")

Как видите, на изображении выше у нас есть еще некое число «**N**» — максимально возможное для нашей трёхбитной системы памяти. Давайте определим, **сколько различных чисел** можем закодировать с помощью трёх битов.

Для этого воспользуемся формулой Хартли:
![[Pasted image 20250525164110.png]]
Здесь:

- **N** — количество различных вариантов кодирования
- **i** — используемое количество бит

По данной формуле имеем количество вариантов кодирования 23, то есть всего **8 вариаций.** Таким образом можем закодировать**,** например, все числа от 0 до 7. Также говорят, что в таком случае мы имеем алфавит из 8 символов или мощность алфавита равна 8.

Естественно, под **алфавитом** здесь подразумевается на буквы _«абв»_ и так далее, а некий **набор символов**. Он может включать в себя как цифры, так и буквы или специальные символы. **Мощность** же алфавита означает **количество символов**, которое содержится в алфавите.

Для вычисления числа бит **i**, которое потребуется для кодирования **N** символов воспользуемся следующей формулой:
![[Pasted image 20250525164127.png]]
Вычислим логарифм числа 5 по основанию 2. Получим приближённое значение **2,322**. Это у нас дробное число, но количество ячеек (бит) всегда должно быть **целым**, мы же не можем разделить и без того минимальную единицу измерения информации.

Встаёт вопрос, как из числа 2,322 получить целое. У нас есть два пути округления: в большую или меньшую сторону. Именно в этом и кроется тонкость решения задания 11 ЕГЭ.

Но давайте рассуждать логически. Мы уже видели, что число 5 имеет значение «101», то есть тут нужно **3 бита**. Тогда, если мы округлим 2,322 до 2, то все наши значения **не поместятся**.

Отсюда следует вывод: применяя формулу Хартли для поиска количества бит всегда округляем результат в **большую** сторону!

И сразу отметим следующее: хоть бит и является минимальной единицей **измерения** информации, но в современных компьютерах минимальной адресуемой единицей **хранения** информации является **1 байт**.

То есть самая маленькая область памяти, куда можем записать значение, будет равняться одному байту.  На подавляющем большинстве современных компьютеров 1 байт состоит из **8 бит**.

Поэтому, если требуется определить объем памяти, необходимый для хранения какой-либо информации, то в результате всегда будут **байты**.

Для перевода значений из байтов в биты и наоборот лучше всего будет запомнить следующие равенства:

1 байт = 8 бит = 2<sup>3</sup> бит

1 Кбайт = 2<sup>10</sup>  байт = 2<sup>10</sup>  · 2<sup>3</sup> бит = 2<sup>13</sup> бит

1 Мбайт = 2<sup>10</sup> Кбайт = 2<sup>10</sup>  · 2<sup>3</sup> байт = 2<sup>20</sup>  · 2<sup>3</sup> бит = 2<sup>23</sup> бит

1 Гбайт = 2<sup>10</sup>  Мбайт = 2<sup>10</sup>  · 2<sup>3</sup> Кбайт = 2<sup>20</sup>  · 2<sup>3</sup> байт = 2<sup>30</sup> · 2<sup>3</sup> бит = 2<sup>33</sup> бит

Немного про терминологию. Сокращение **Кбайт** (или **КБ**) означает «**кило**байт». Один килобайт равен 1024 байт, хотя традиционно десятичная приставка «**Кило-**» означает умножение на 1000, а не 1024.

В англоязычной литературе можете встретить иной термин: **Кибибайт** (KiB), который будет означать 1024 байт, когда **Килобайт** (KB) — 1000 байт. Далее аналогично **Меби**байт = 1024 **Киби**байт, **Гиби**байт = 1024 **Меби**байт и так далее. То есть здесь используются **двоичные** приставки, а не десятичные.

От этого порой могут страдать потребители, которые покупают флеш-накопитель. На таком изделии может быть указана ёмкость в 1 **Гига**байт, что равняется 1 000 000 000 байт. А покупатель же предполагает, что ёмкость указана в привычных ему единицах (**Гиби**байт) и составляет 1 073 741 824 байт.

Но в нашей стране все же принято, что 1 Килобайт это 1024 байт, 1 Мегабайт это 1024 Килобайт и так далее.

Еще одно непонимание у пользователя может возникнуть при определении **скорости передачи данных**. Например, вы видите скорость в 100 **Мб** в секунду. Но файл, который весит 900 **Мега**байт почему-то скачивается не за 9 секунд.

Тут опять же дело в том, что сокращение «Мб» означает «Мега**бит**» (на английском будет понятней — «Mbit»), а не «Мега**байт**» (обратите внимание на букву **«б»,** при обозначении битов она строчная). И как раз скорость передачи данных принято обозначать в **битах**, Кило**битах**, Мега**битах** и так далее.

Возвращаясь же к заданию 11 ЕГЭ по информатике, помните, что если вы работаете с объёмом памяти сообщения, то он должен быть выражен в **байтах**. Тогда как вес символа должен быть представлен в **битах**. При подставлении объёма сообщения и веса символа в одну формулу, например для вычисления длины сообщения, не забывайте приводить все значения **к одной размерности**!

## Объём текстовой информации

Итак, мы уже разобрались с тем, как хранится информация на компьютере и как найти вес одного символа, зная мощность алфавита. Но одного символа нам явно не хватит, чтобы закодировать нужное нам **сообщение**. Этим сообщением, например, может быть как любая текстовая информация, так и пароль или серийный номер изделия.

Что мы знаем точно, так это то, что у этого сообщения должна быть определённая **длина** — количество символов, из которых состоит каждое сообщение. Тогда, зная вес одного символа (**i**) и длину сообщения (**L**), можем вычислить и объём всего сообщения:

![I = L \cdot i](https://future-step.ru/wp-content/ql-cache/quicklatex.com-e4d9dddeacecd78278ee02955d893c85_l3.svg "Rendered by QuickLaTeX.com")

Если же требуется определить максимально возможную **длину одного сообщения**, то из формулы выше выразим значение L:

![L = \frac{I}{i}](https://future-step.ru/wp-content/ql-cache/quicklatex.com-af6bdb83aeaec0df9fd31df99863d0dc_l3.svg "Rendered by QuickLaTeX.com")

При этом, результат формулы может оказаться дробным. Здесь вспоминаем случай с вычислением веса символа и действуем наоборот: если получилась длина сообщения «2,322», то вместить 3 символа мы никак не сможем. И округлять здесь нужно **в меньшую сторону**!

## Алгоритм решения 11 задания

У нас на руках есть все формулы, необходимые для решения этого задания:

![I = L \cdot i](https://future-step.ru/wp-content/ql-cache/quicklatex.com-e4d9dddeacecd78278ee02955d893c85_l3.svg "Rendered by QuickLaTeX.com") , ![i = \log_2N](https://future-step.ru/wp-content/ql-cache/quicklatex.com-10b3a91f198e11e9b79c556b9cfb75cf_l3.svg "Rendered by QuickLaTeX.com")

Все, то от нас требуется — правильно произвести расчеты, не ошибиться в округлении и перевести результат в нужную размерность.

### Формулировка 1

Нам дана мощность алфавита **N**. Также сказано, что для хранения **K** сообщений отведено не более / не менее **X** байт.  То есть это вес одного сообщения, умноженный на какое-то число **K**. Здесь требуется найти максимально возможную длину сообщения — значение **L** из формулы выше.

Для решения будем использовать следующую формулу:

![L = \frac{I}{\log_2N}](https://future-step.ru/wp-content/ql-cache/quicklatex.com-fe2d0feab316899fc5af4a4584371e31_l3.svg "Rendered by QuickLaTeX.com")

Сначала найдем вес одного **символа**. Для этого вычислим логарифм по основания 2 от мощности алфавита.

Затем определяем вес одного **сообщения**: делим указанный объем **X** на количество сообщений **K**. Здесь обратите внимание на формулировку. Если в условии указано, что «для хранения K сообщений отведено **не более** X байт», то округляем полученное значение в **меньшую** сторону. Если указано обратное — «**не менее** X байт», то округляем в **большую** сторону.

Далее подставляем все значения в формулу. Не забываем учесть все размерности. Результат обычно получается дробным числом, а в ответ просят записать только **целую** часть этого числа.

### Формулировка 2

Здесь нам также даётся мощность алфавита **N**, длина сообщения **L**, а нам необходимо найти объем памяти **I** для хранения **K** сообщений.

Для решения будем использовать следующую формулу:

![I = \log_2N \cdot L \cdot K](https://future-step.ru/wp-content/ql-cache/quicklatex.com-8664cffb06811974e46c7dc12b9497fc_l3.svg "Rendered by QuickLaTeX.com")

Сначала определим, сколько бит занимает **один символ**. Это будет логарифм по основанию 2 от числа **N**. Не забываем округлять в **большую** сторону.

Далее вычисляем вес одного сообщения в **байтах**, умножая вес одного символа на длину сообщения. Получаем значения в битах, которое переводим в байты — делим результат на 8 и не забываем про округление.

Потом определяем, сколько будет весить все **K** сообщений. И приводим к необходимой по условию размерности. Так, как мы получили число в байтах, то для перевода в **Килобайты** — делим на 210, в **Мегабайты** — 220.

Как видите, в любой формулировке достаточно подставить имеющиеся значения в формулу и правильно перевести результат в требуемую размерность. Рассмотрим несколько примеров для закрепления.